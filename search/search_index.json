{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Description","text":"<p>Source code: https://github.com/maximshumilo/fastapi-restful-extension </p> <p>PyPI: https://pypi.org/project/fastapi-restful-extension/ </p> <p>FastAPI-RESTful-Extension - is extension for FastAPI that allows you to easily create a REST API.</p> <p>In this extension, the API is built using the Resource classes. They are built based on the capabilities of FastAPI, namely <code>APIRouter</code> and <code>Route</code></p> <p>The Resource classes provide easy access to HTTP methods.</p>"},{"location":"get-help/","title":"Get Help","text":""},{"location":"get-help/#star-fastapi-restful-extension-in-github","title":"Star FastAPI-RESTful-Extension in GitHub","text":"<p>You can \"star\" FastAPI-RESTful-Extension in GitHub (clicking the star button at the top right). \u2b50\ufe0f</p> <p>By adding a star, other users will be able to find it more easily and see that it has been already useful for others.</p>"},{"location":"get-help/#watch-the-github-repository-for-releases","title":"Watch the GitHub repository for releases","text":"<p>You can \"watch\" FastAPI-RESTful-Extension  in GitHub (clicking the \"watch\" button at the top right). \ud83d\udc40</p> <p>There you can select \"Releases only\".</p> <p>By doing it, you will receive notifications (in your email) whenever there's a new release (a new version) of FastAPI-RESTful-Extension with bug fixes and new features.</p>"},{"location":"get-help/#connect-with-the-author","title":"Connect with the author","text":"<p>You can connect with me (Shumilo Maxim / <code>maximshumilo</code>), the author.</p> <p>You can:</p> <ul> <li>Follow me on GitHub.<ul> <li>See other Open Source projects I have created that could help you.</li> <li>Follow me to see when I create a new Open Source project.</li> </ul> </li> <li>Connect with me on Telegram.</li> <li>Connect with me on Linkedin.</li> </ul>"},{"location":"get-help/#help-others-with-issues-in-github","title":"Help others with issues in GitHub","text":"<p>You can see existing issues and try and help others, most of the times they are questions that you might already know the answer for. \ud83e\udd13</p>"},{"location":"get-help/#create-issues","title":"Create issues","text":"<p>You can create a new issue in the GitHub repository, for example to:</p> <ul> <li>Ask a question or ask about a problem.</li> <li>Suggest a new feature.</li> </ul> <p>Note: if you create an issue, then I'm going to ask you to also help others. \ud83d\ude09</p>"},{"location":"get-help/#join-the-chat","title":"Join the chat","text":"<p>Join the \ud83d\udc65 Discord chat server \ud83d\udc65 and hang out with others in the FastAPI community.</p>"},{"location":"get-help/#dont-use-the-chat-for-questions","title":"Don't use the chat for questions","text":"<p>Have in mind that as chats allow more \"free conversation\", it's easy to ask questions that are too general and more difficult to answer, so, you might not receive answers.</p> <p>In GitHub issues the template will guide you to write the right question so that you can more easily get a good answer, or even solve the problem yourself even before asking. And in GitHub I can make sure I always answer everything, even if it takes some time. I can't personally do that with the chat systems. \ud83d\ude05</p> <p>Conversations in the chat systems are also not as easily searchable as in GitHub, so questions and answers might get lost in the conversation. And only the ones in GitHub issues count to become a FastAPI Expert, so you will most probably receive more attention in GitHub issues.</p> <p>On the other side, there are thousands of users in the chat systems, so there's a high chance you'll find someone to talk to there, almost all the time. \ud83d\ude04</p> <p>Thanks! \ud83d\ude80</p>"},{"location":"installation/","title":"Installation","text":"<p>FastAPI-RESTful-Extension has the following dependencies:</p> <ul> <li>FastAPI &lt;= <code>0.78.0</code></li> <li>Python version: <code>3.7, 3.8, 3.9</code> or <code>3.10</code></li> </ul>"},{"location":"installation/#from-pypi","title":"From PyPI","text":"<p>Install package with pip from PyPI</p> <pre><code>$ pip install fastapi-restful-extension\n\nCollecting fastapi-restful-extension\n...\n...\n...\nInstalling collected packages: fastapi-restful-extension\nSuccessfully installed fastapi-restful-extension-X.Y.Z\n</code></pre>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#changelog","title":"Changelog","text":""},{"location":"release-notes/#030","title":"0.3.0","text":"<ul> <li>Add decorator route_settings</li> <li>Add method apply for class RESTExtension</li> <li>Fix bugs and update logic init API</li> </ul>"},{"location":"release-notes/#020","title":"0.2.0","text":"<ul> <li>Rename Api class to RESTExtension</li> <li>Add BaseRestAPI</li> <li>Add api version and method <code>create-version</code> to RESTExtension</li> </ul>"},{"location":"release-notes/#010","title":"0.1.0","text":"<ul> <li>Add Resource class</li> <li>Add Api class</li> <li>Add tests, 100% covered</li> </ul>"},{"location":"release-notes/#001","title":"0.0.1","text":"<ul> <li>Init repo and add base structure</li> </ul>"},{"location":"user-guide/minimal-api/","title":"Minimal API","text":"<p>Here are the steps to create a minimal api for \"FastAPI\" using FastAPI-RESTful-Extension.</p>"},{"location":"user-guide/minimal-api/#install-uvicorn-for-run-server","title":"Install <code>uvicorn</code> for run server.","text":"<pre><code>$ pip install uvicorn\nCollecting uvicorn\n  Using cached uvicorn-0.17.6-py3-none-any.whl (53 kB)\n...\n...\n...\nInstalling collected packages: h11, asgiref, uvicorn\nSuccessfully installed asgiref-3.5.2 h11-0.13.0 uvicorn-0.17.6\n</code></pre>"},{"location":"user-guide/minimal-api/#create-a-file-first_apipy-and-fill-it-with-the-following-contents","title":"Create a file <code>first_api.py</code> and fill it with the following contents.","text":"first_api.py<pre><code>from fastapi import FastAPI\nfrom fastapi_restful import RESTExtension, Resource\nfrom uvicorn import run\napp = FastAPI()\napi = RESTExtension(app)\nclass FirstResource(Resource):\ndef get(self):\nreturn {'first': 'resource'}\napi.add_resource(FirstResource, path='/first-resource')\napi.apply()\nif __name__ == '__main__':\nrun('first_api:app')\n</code></pre> <p>The FastAPI application will be created and routes with methods described in the <code>FirstResource</code> class will be connected.</p> <p>Note</p> <p><code>/api/...</code> - this prefix is added by default to the <code>RESTExtension</code> instance.  If you don't need it, specify <code>prefix=None</code> when initializing <code>RESTExtension</code></p> first_api.py<pre><code>from fastapi import FastAPI\nfrom fastapi_restful import RESTExtension, Resource\nfrom uvicorn import run\napp = FastAPI()\napi = RESTExtension(app)\nclass FirstResource(Resource):\ndef get(self):\nreturn {'first': 'resource'}\napi.add_resource(FirstResource, path='/first-resource')\napi.apply()\nif __name__ == '__main__':\nrun('first_api:app')\n</code></pre> <p>The <code>FirstResource</code> class inherited from <code>Resource</code> is declared, in it declares a method for processing the corresponding http request.</p> <p>Then this class with its URLs passed to <code>api.add_resource()</code></p> <p>The <code>api.apply()</code> method include all declared routes from <code>api</code> to FastAPI</p> <p>As a result one route will be registered - <code>GET /api/first-resource/</code></p>"},{"location":"user-guide/minimal-api/#run-api","title":"Run api.","text":"<pre><code>$ python first_api.py\n\nINFO:     Started server process [71507]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n</code></pre>"},{"location":"user-guide/minimal-api/#check-created-api","title":"Check created api.","text":"<pre><code>$ curl http://127.0.0.1:8000/api/first-resource\n{\"first\":\"resource\"}\n</code></pre>"},{"location":"user-guide/resourceful/","title":"Routing","text":"<p>In this extension, the API is built using the <code>Resource</code> classes. They are built based on the capabilities of <code>FastAPI</code>, namely <code>APIRouter</code> and <code>Route</code></p> <p>The <code>Resource</code> classes provide easy access to HTTP methods. </p>"},{"location":"user-guide/resourceful/#example-of-crud-operations","title":"Example of CRUD operations:","text":"<p>Consider an example with posts. </p> <p>Note</p> <p><code>posts = []</code> is used as a simulation of the database <code>posts</code> table.</p> posts.py<pre><code>from uuid import UUID, uuid4\nfrom fastapi import FastAPI, Response, HTTPException, Query\nfrom fastapi_restful import RESTExtension, Resource\nfrom pydantic import BaseModel, Field\nfrom uvicorn import run\napp = FastAPI()\napi = RESTExtension(app)\nposts = []\nclass NewPost(BaseModel):\nid: UUID = Field(default_factory=uuid4)\nbody: str\nclass UpdatePost(BaseModel):\nbody: str\nclass Posts(Resource):\ndef get(self, query_param: str = Query(None, description='My query')):\nreturn {'items': posts, 'total_count': len(posts)}\ndef post(self, new_post: NewPost):\nposts.append(new_post)\nreturn {'post_id': new_post.id}\nclass SpecificPost(Resource):\ndef get(self, post_id: UUID):\npost = next(filter(lambda x: x.id == post_id, posts), None)\nif post is None:\nraise HTTPException(status_code=404)\nreturn post\ndef put(self, post_id: UUID, new_data: UpdatePost):\npost = next(filter(lambda x: x.id == post_id, posts), None)\nif post is None:\nraise HTTPException(status_code=404)\npost.body = new_data.body\nreturn post\ndef delete(self, post_id: UUID):\npost = next(filter(lambda x: x.id == post_id, posts), None)\nif post is None:\nreturn Response(status_code=204)\nposts.remove(post)\nreturn Response(status_code=204)\nurls = {\n'/posts': Posts,\n'/posts/{post_id}': SpecificPost\n}\nfor path, resource in urls.items():\napi.add_resource(resource, path=path)\napi.apply()\nif __name__ == '__main__':\nrun('posts:app')\n</code></pre>"},{"location":"user-guide/resourceful/#serialization-of-input-data","title":"Serialization of input data","text":"<p>posts.py<pre><code>...\nclass NewPost(BaseModel):\nid: UUID = Field(default_factory=uuid4)\nbody: str\nclass UpdatePost(BaseModel):\nbody: str\nclass Posts(Resource):\ndef get(self, query_param: str = Query(None, description='My query')):\nreturn {'items': posts, 'total_count': len(posts)}\ndef post(self, new_post: NewPost):\nposts.append(new_post)\nreturn {'post_id': new_post.id}\nclass SpecificPost(Resource):\ndef get(self, post_id: UUID):\npost = next(filter(lambda x: x.id == post_id, posts), None)\nif post is None:\nraise HTTPException(status_code=404)\nreturn post\ndef put(self, post_id: UUID, new_data: UpdatePost):\npost = next(filter(lambda x: x.id == post_id, posts), None)\nif post is None:\nraise HTTPException(status_code=404)\npost.body = new_data.body\nreturn post\ndef delete(self, post_id: UUID):\npost = next(filter(lambda x: x.id == post_id, posts), None)\nif post is None:\nreturn Response(status_code=204)\nposts.remove(post)\nreturn Response(status_code=204)\n...\n</code></pre> You can declare <code>pydantic</code> models for serialize body, query and path parameters,  just like you would do with a standard route declaration in <code>FastAPI</code></p>"},{"location":"user-guide/resourceful/#declaring-urls","title":"Declaring urls","text":"<p>posts.py<pre><code>...\nurls = {\n'/posts': Posts,\n'/posts/{post_id}': SpecificPost\n}\nfor path, resource in urls.items():\napi.add_resource(resource, path=path)\napi.apply()\n...\n</code></pre> Declare the path in the <code>urls</code> dictionary, where the key is the path to the resource, and the value is the corresponding class.</p> <p>Note</p> <p>It is allowed not to specify the route paths in the <code>urls</code> dictionary, but instead to specify them in the classes themselves, in the <code>path</code> attribute.</p> <p>In this case, only your class should be passed to the <code>add_resource</code> method.</p> <p>And then the familiar commands are already coming: </p> <ul> <li><code>add_resource</code> - Add a resource to the api</li> <li><code>apply</code> - include all declared routes from <code>api</code> to your <code>FastAPI</code> app</li> </ul> <p>As a result, you will have 5 routes announced:</p> <ul> <li><code>GET /api/posts</code></li> <li><code>POST /api/posts</code></li> <li><code>GET /api/posts/{post_id}</code></li> <li><code>PUT /api/posts/{post_id}</code></li> <li><code>DELETE /api/posts/{post_id}</code></li> </ul>"},{"location":"user-guide/resourceful/#route-settings","title":"Route settings","text":"<p>You probably know that <code>FastAPI</code> allows you to pass various arguments when declaring a route, such as: <code>summary</code>, <code>response_model</code> etc. Here it can also be done using the <code>route_settings</code> decorator.</p> posts.py<pre><code>from uuid import UUID, uuid4\nfrom fastapi import FastAPI, Response, HTTPException, Query\nfrom fastapi_restful import RESTExtension, Resource, route_settings\nfrom pydantic import BaseModel, Field\nfrom uvicorn import run\n...\n</code></pre> <p>Import <code>route_settings</code></p> <p>posts.py<pre><code>...\nclass Posts(Resource):\n@route_settings(summary='Get all posts')\ndef get(self, query_param: str = Query(None, description='My query')):\nreturn {'items': posts, 'total_count': len(posts)}\n...\n</code></pre> With this decorator, we can throw all the arguments that accepts method the <code>FastAPI.add_api_route</code>.</p> <p>Note</p> <p>The example below is absolutely identical. In this example, the route is declared with standard <code>FastAPI</code> methods.</p> <pre><code>app.get('/api/posts', summary='Get all posts')\ndef all_posts(self, query_param: str = Query(None, description='My query param')):\nreturn {'items': posts, 'total_count': len(posts)}\n</code></pre>"},{"location":"user-guide/resourceful/#resource-tag","title":"Resource tag","text":"<p>The <code>Resource</code> class has the <code>tag</code> attribute.  We can set it a value, for example, for grouping routes in the <code>swagger</code> documentation.</p> <p>posts.py<pre><code>...\nclass Posts(Resource):\ntag = 'Manage posts'\n@route_settings(summary='Get all posts')\ndef get(self, query_param: str = Query(None, description='My query')):\nreturn {'items': posts, 'total_count': len(posts)}\ndef post(self, new_post: NewPost):\nposts.append(new_post)\nreturn {'post_id': new_post.id}\nclass SpecificPost(Resource):\ntag = 'Manage posts'\ndef get(self, post_id: UUID):\npost = next(filter(lambda x: x.id == post_id, posts), None)\nif post is None:\nraise HTTPException(status_code=404)\nreturn post\ndef put(self, post_id: UUID, new_data: UpdatePost):\npost = next(filter(lambda x: x.id == post_id, posts), None)\nif post is None:\nraise HTTPException(status_code=404)\npost.body = new_data.body\nreturn post\ndef delete(self, post_id: UUID):\npost = next(filter(lambda x: x.id == post_id, posts), None)\nif post is None:\nreturn Response(status_code=204)\nposts.remove(post)\nreturn Response(status_code=204)\n...\n</code></pre> Set the value <code>Manage posts</code> for each attribute <code>tag</code> of the <code>Resource</code> classes.</p> <p>If you launch the application and open the documentation page in the browser (<code>http://127.0.0.1:8000/docs</code>),  you will see that all routes are grouped by tag the <code>Manage posts</code> </p>"},{"location":"user-guide/versions/","title":"Versions API","text":"<p>This extension allows you to create separate versions of the api.  At the same time, the prefix specified during version initialization is added to the url of the main API.</p>"},{"location":"user-guide/versions/#creating-second-version-api","title":"Creating second version API","text":"<p>As an example, let's add a version to the previous example from the Minimal API section.</p> <p>first_api.py<pre><code>from fastapi import FastAPI\nfrom uvicorn import run\nfrom fastapi_restful import RESTExtension, Resource, RESTExtension\napp = FastAPI()\napi = RESTExtension(app)\nclass FirstResource(Resource):\ndef get(self):\nreturn {'first': 'resource'}\nclass SecondResource(Resource):\ndef get(self):\nreturn {'second': 'resource'}\nv2 = RESTExtension(prefix='v2')\nv2.add_resource(SecondResource, path='/second-resource')\napi.add_rest_api()\napi.add_resource(FirstResource, path='/first-resource')\napi.apply()\nif __name__ == '__main__':\nrun('first_api:app')\n</code></pre> The <code>SecondResource</code> class is declared by analogy with <code>FirstResource</code>.</p> <p>A new version of the API with the prefix <code>v2</code> has been created and the <code>SecondResource</code> class and the path by which it can be accessed have been added to it</p> <p>As a result, two routes will be registered:</p> <ul> <li><code>GET /api/first-resource/</code></li> <li><code>GET /api/v2/second-resource/</code></li> </ul> <p>Note</p> <p>\u041dou can get an instance of <code>RESTExtension</code> using the <code>__getitem__</code> method from the <code>RESTExtension</code> instance by a prefix.</p> <pre><code>&gt;&gt;&gt; api_v2 = api.create_version('v2')\n&gt;&gt;&gt; api['v2'] is api_v2\nTrue\n</code></pre>"}]}